### 1、ForeignKey

模型示例

```python
from django.db import models
classBlog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()
classAuthor(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()
classEntry(models.Model):
    blog = models.ForeignKey(Blog)
    authors = models.ManyToManyField(Author)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()
```

**classForeignKey**
ForeignKey字段接受一个Model类作为参数,类型与被参照的字段完全相同:

```python
 blog = models.ForeignKey(Blog)
```

**ForeignKey.to_field**
关联到的关联对象的字段名称。默认地，Django使用关联对象的主键。

```python
blog = models.ForeignKey(Blog, to_field=Blog.name)
```

**ForeignKey.db_constraint**
Django Model的ForeignKey字段的主要功能是维护一个一对多的关系, 以进行关联查询.
只有在db_constraint=True时Django model才会在数据库上建立外键约束, 在该值为False时不建立约束.
默认db_constraint=True.
**ForeignKey.related_name**
这个名称用于让关联的对象反查到源对象.
如果你不想让Django 创建一个反向关联，请设置related_name 为 '+' 或者以'+' 结尾.
ForeignKey.related_query_name以ForeignKey.related_name作为默认值。

### 2、ManyToManyField

来自官网的例子

```python
from django.db import models
 
class Person(models.Model):
    name = models.CharField(max_length=50)
 
class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'))
 
class Membership(models.Model):
    group = models.ForeignKey(Group)
    person = models.ForeignKey(Person)
    inviter = models.ForeignKey(Person, related_name="membership_invites")
    invite_reason = models.CharField(max_length=64)
```

**ManyToManyField.through**
Django会自动创建一个表来管理多对多关系,若要手动指定关联表则需要使用through关键字参数.
**ManyToManyField.through_fields**
上文示例中Membership有两个外键指向Person(person和inviter)，这使得关联关系含混不清并让Django不知道使用哪一个。在这种情况下，必须使用through_fields明确指定Django应该使用哪些外键
through_fields接收一个二元组('field1','field2')，其中field1为指向定义ManyToManyField字段的模型的外键名称(本例中为group)，field2为指向目标模型的外键的名称(本例中为person).
**ManyToManyField.db_table**
默认情况下,关联表的名称使用多对多字段的名称和包含这张表的模型的名称以及Hash值生成,如:memberShip_person_3c1f5
若要想要手动指定表的名称,可以使用db_table关键字参数指定.
**others**
下列API和ForeignKey中的同名API相同.
ManyToManyField.db_constraint
ManyToManyField.related_name
ManyToManyField.related_query_name

**注意：**

对于最新版本的django2.0在使用OneToOneField和ForeignKey时，需要加上on_delete参数。

on_delete参数的各个值的含义：

```python
on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为
on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除
on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做
on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError
# models.ForeignKey('关联表', on_delete=models.SET_NULL, blank=True, null=True)
on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）
# models.ForeignKey('关联表', on_delete=models.SET_DEFAULT, default='默认值')
on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）
on_delete=models.SET,         # 删除关联数据,
 a. 与之关联的值设置为指定值,设置：models.SET(值)
 b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)
```